/* eslint-env node, mocha */
'use strict';

const Crypto = require('crypto');

const _ = require('lodash');
const chai = require('chai');
const chaiAsPromised = require('chai-as-promised');

const Transformation = require('../classes/transformation');

const expect = chai.expect;
chai.use(chaiAsPromised);

/**
 * Transformations define how objects can be transformed from one format to another.
 * Input and output objects are always in JSON format.
 *
 * The transformation process is a chain of processing functions, each function
 * processing the output of the preceding function.
 * A transformation template itself is a JSON object in which each key is a
 * processing function. Example template in YAML:
 * ```yaml
 * single: $.data
 * object:
 *   foo: $.bar
 * ```
 * This template will convert ``{data:{bar:"baz"}}`` to ``{bar:"baz"}`` in the
 * first step and finally to ``{foo:"baz"}`` in the second.
 * Templates can also transform arrays:
 * ```yaml
 * multiple: $.items
 * map:
 *   baz: $.qux
 * ```
 * This will convert ``{items:[{qux:"quux"},{qux:"garply"}]}`` to
 * ``[{baz:"quux"},{baz:"garply"}]``.
 *
 * [JSONPath](https://www.npmjs.com/package/jsonpath) is used for the selectors.
 * The result of a JSONPath query is always an array, but the result has only
 * one object in many cases. The "single" operator only returns the first item,
 * or ``null`` if nothing was found. The "multiple" operator will return the
 * array as-is.
 *
 * More complex structures can be generated by the "object" operator. Each property
 * of this object will be added as a property in the output as well. The value
 * for this property is a new transformation chain, or a query string, which is
 * a shorthand for ``{single: "query"}``.
 */
describe('Transformation', () => {
  it('can execute empty transformation', () => {
    const transformer = new Transformation({});
    expect(transformer.transform({})).to.deep.equal({});
  });

  it('can return single item from jsonpath query', () => {
    const transformer = new Transformation({
      single: '$.data'
    });
    expect(transformer.transform({data: {foo: 'bar'}})).to.deep.equal({foo: 'bar'});
  });

  it('can return multiple items from jsonpath query', () => {
    const transformer = new Transformation({
      multiple: '$.data'
    });
    expect(transformer.transform({data: {foo: 'bar'}})).to.deep.equal([{foo: 'bar'}]);
  });

  it('can generate static value', () => {
    const transformer = new Transformation({
      static: {foo: 'bar'}
    });
    expect(transformer.transform({data: {foo: 'bar'}})).to.deep.equal({foo: 'bar'});
  });

  it('can transform objects', () => {
    const transformer = new Transformation({
      object: {baz: '$.foo'}
    });
    expect(transformer.transform({foo: 'bar'})).to.deep.equal({baz: 'bar'});
  });

  it('can transform nested objects', () => {
    const transformer = new Transformation({
      object: {
        foo: {
          single: '$.foo',
          object: {
            bar: '$.baz'
          }
        }
      }
    });
    expect(transformer.transform({
      foo: {
        baz: 'test'
      }
    })).to.deep.equal({
      foo: {
        bar: 'test'
      }
    });
  });

  it('can map arrays', () => {
    const transformer = new Transformation({
      map: {object: {baz: '$.foo'}}
    });
    expect(transformer.transform([
      {foo: 'qux'},
      {foo: 'quux'}
    ])).to.deep.equal([
      {baz: 'qux'},
      {baz: 'quux'}
    ]);
  });

  it('can get substring', () => {
    const transformer = new Transformation({
      substring: {start: 1, length: 5}
    });
    expect(transformer.transform('Lorem ipsum')).to.equal('orem ');
  });

  it('can get substring without providing length', () => {
    const transformer = new Transformation({
      substring: {start: 1}
    });
    expect(transformer.transform('Lorem ipsum')).to.equal('orem ipsum');
  });

  it('can get substring without providing start', () => {
    const transformer = new Transformation({
      substring: {length: 5}
    });
    expect(transformer.transform('Lorem ipsum')).to.equal('Lorem');
  });

  it('can get length of array', () => {
    const transformer = new Transformation({
      length: {}
    });
    expect(transformer.transform([1, 2, 3])).to.equal(3);
  });

  it('can get length of string', () => {
    const transformer = new Transformation({
      length: {}
    });
    expect(transformer.transform('test')).to.equal(4);
  });

  it('can get md5/hex hash of a string', () => {
    const transformer = new Transformation({
      hash: {algorithm: 'md5', encoding: 'hex'}
    });
    expect(transformer.transform('Lorem')).to.equal(Crypto.createHash('md5').update('Lorem').digest('hex'));
  });

  it('can get sha1/base64 hash of a string', () => {
    const transformer = new Transformation({
      hash: {algorithm: 'sha1', encoding: 'base64'}
    });
    expect(transformer.transform('Lorem')).to.equal(Crypto.createHash('sha1').update('Lorem').digest('base64'));
  });

  it('defaults to md5/hex when not providing arguments for hash', () => {
    const transformer = new Transformation({
      hash: {}
    });
    expect(transformer.transform('Lorem')).to.equal(Crypto.createHash('md5').update('Lorem').digest('hex'));
  });
});
