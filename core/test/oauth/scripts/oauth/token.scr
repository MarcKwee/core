# OauthToken

/now = round parseInt date "X"

/client = read {
  model: "OauthClient",
  id: /client_id
}

/ = (/client/type == "confidential") then {{
  # Check the client authorization.
  # This can be done via HTTP basic authentication or the client_secret field.
  /allow = (/headers/authorization == ("Basic " + base64 /client/id + ":" + /client/secret)) or /client_secret == /client/secret
  (!/allow) then error {type: "Unauthorized"}
}}

/data/status = 400

/ = (/grant_type == "authorization_code") then {{
  /codes = select {
    model: "OauthAuthorizationCode",
    filters: {
      code: /code,
      client: /client/id,
      expires_gte: /now
    },
    selections: {items: {code: {}, scope: {}, user: {id: {}}, client: {id: {}}}}
  }
  / = /codes/items/0 then {{
    # Immediately delete code, as this is a one-time token.
    delete {
      model: "OauthAuthorizationCode",
      id: /codes/items/0/id
    }

    # Check if an access token already exists.
    # Only remember login when token is still valid for at least 15 minutes.
    /tokens = select {
      model: "OauthAccessToken",
      filters: {
        client: /codes/items/0/client/id,
        user: /codes/items/0/user/id,
        scope: /codes/items/0/scope,
        expires_gt: /now + 900
      },
      selections: {items: {id: {}, token: {}, expires: {}, user: {id: {}}, client: {id: {}, type: {}}}}
    }

    / = /tokens/items/0/id then {{
      /data/body = {
        access_token: /tokens/items/0/token,
        token_type: "bearer",
        user_id: /tokens/items/0/user/id,
        expires_in: /tokens/items/0/expires - /now
      }
      # Also re-use the refresh token for confidential clients.
      / = (/tokens/items/0/client/type == "confidential") then {{
        /refresh_tokens = select {
          model: "OauthRefreshToken",
          filters: {
            client: /codes/items/0/client/id,
            user: /codes/items/0/user/id,
            scope: /codes/items/0/scope,
            expires_gt: /nwo + 900
          },
          selections: {items: {token: {}}}
        }
        /data/body/refresh_token = /refresh_tokens/items/0/token
      }}
    }}

    / = (!/tokens/items/0/id) then {{
      # Create a new access token.
      /token = {
        client: /codes/items/0/client,
        user: /codes/items/0/user,
        scope: /codes/items/0/scope
      } script "OauthCreateToken"
      /data/body = {
        access_token: /token/token,
        token_type: "bearer",
        user_id: /token/user,
        expires_in: /token/expires - /now
      }
      / = /token/refresh_token then {{
        /data/body/refresh_token = /token/refresh_token
      }}
    }}

    /data/status = 200
  }}

}}

/ = (/grant_type == "refresh_token") then {{
  /refresh_tokens = select {
    model: "OauthRefreshToken",
    filters: {
      token: /refresh_token,
      client: /client/id,
      expires_gte: /now
    },
    selections: {items: {id: {}, scope: {}, user: {id: {}}, client: {id: {}, type: {}}}}
  }
  / = /refresh_tokens/items/0 then {{
    # Delete old refresh token.
    delete {
      model: "OauthRefreshToken",
      id: /refresh_tokens/items/0/id
    }
    # Create a new access token.
    /token = {
      client: /client,
      user: /refresh_tokens/items/0/user,
      scope: /refresh_tokens/items/0/scope
    } script "OauthCreateToken"
    /data/body = {
      access_token: /token/token,
      token_type: "bearer",
      user_id: /token/user,
      expires_in: /token/expires - /now
    }
    /data/body/refresh_token = /token/refresh_token
    /data/status = 200
  }}
}}

# Set security related headers.
/"data/headers/Cache-Control" = "no-store"
/data/headers/Pragma = "no-cache"

/ = /data
